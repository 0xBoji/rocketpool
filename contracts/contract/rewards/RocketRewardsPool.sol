pragma solidity 0.7.6;

// SPDX-License-Identifier: GPL-3.0-only

import "../RocketBase.sol";
import "../../interface/token/RocketTokenRPLInterface.sol";
import "../../interface/rewards/RocketRewardsPoolInterface.sol";
import "../../interface/dao/protocol/settings/RocketDAOProtocolSettingsNetworkInterface.sol";
import "../../interface/dao/node/RocketDAONodeTrustedInterface.sol";
import "../../interface/network/RocketNetworkBalancesInterface.sol";
import "../../interface/RocketVaultInterface.sol";
import "../../interface/dao/protocol/settings/RocketDAOProtocolSettingsRewardsInterface.sol";

import "@openzeppelin/contracts/math/SafeMath.sol";


// Holds RPL generated by the network for claiming from stakers (node operators etc)

contract RocketRewardsPool is RocketBase, RocketRewardsPoolInterface {

    // Libs
    using SafeMath for uint;

    // Events
    event RewardSnapshotSubmitted(address indexed from, uint256 index, uint256 totalRewards, bytes32 merkleRoot, uint256[] rewardsPerNetwork, Multihash merkleTreeCID, uint256 time);
    event RewardSnapshotInserted(uint256 index, uint256 totalRewards, bytes32 merkleRoot, uint256[] rewardsPerNetwork, Multihash merkleTreeCID, uint256 time);

    // Struct to store IPFS CID
    struct Multihash {
        bytes32 hash;
        bytes2 hashFunction;
        uint8 size;
    }

    // Construct
    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {
        // Version
        version = 2;
    }

    function getRewardIndex() public view returns(uint256) {
        return getUint(keccak256("rewards.snapshot.index"));
    }
    function incrementRewardIndex() private {
        addUint(keccak256("rewards.snapshot.index"), 1);
    }

    /**
    * Get how much RPL the Rewards Pool contract currently has assigned to it as a whole
    * @return uint256 Returns rpl balance of rocket rewards contract
    */
    function getRPLBalance() override public view returns(uint256) {
        // Get the vault contract instance
        RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress("rocketVault"));
        // Check contract RPL balance
        return rocketVault.balanceOfToken("rocketRewardsPool", IERC20(getContractAddress("rocketTokenRPL")));
    }

    // Returns the total amount of RPL that needs to be distributed to claimers at the current block
    function getPendingRewards() public view returns (uint256) {
        RocketTokenRPLInterface rplContract = RocketTokenRPLInterface(rplContractAddress);
        uint256 pendingInflation = rplContract.inflationCalculate();
        // Any inflation that has accrued so far plus any amount that would be minted if we called it now
        return getRPLBalance().add(pendingInflation);
    }

    /**
    * Get the last set interval start time
    * @return uint256 Last set start timestamp for a claim interval
    */
    function getClaimIntervalTimeStart() override public view returns(uint256) {
        return getUint(keccak256("rewards.pool.claim.interval.time.start"));
    }

    /**
    * Get how many seconds in a claim interval
    * @return uint256 Number of seconds in a claim interval
    */
    function getClaimIntervalTime() override public view returns(uint256) {
        // Get from the DAO settings
        RocketDAOProtocolSettingsRewardsInterface daoSettingsRewards = RocketDAOProtocolSettingsRewardsInterface(getContractAddress("rocketDAOProtocolSettingsRewards"));
        return daoSettingsRewards.getRewardsClaimIntervalTime();
    }

    /**
    * Compute intervals since last claim period
    * @return uint256 Time intervals since last update
    */
    function getClaimIntervalsPassed() override public view returns(uint256) {
        return block.timestamp.sub(getClaimIntervalTimeStart).div(getClaimIntervalTime);
    }

    // Submit a reward snapshot
    // Only accepts calls from trusted (oracle) nodes
    function submitRewardSnapshot(uint256 _index, uint256 _totalRewards, uint256[] _rewardsPerNetwork, bytes32 _merkleRoot, Multihash calldata _merkleTreeCID) override external onlyLatestContract("rocketRewardsPool", address(this)) onlyTrustedNode(msg.sender) {
        // Validate index value
        require(_index == getRewardIndex().add(1), "Can only submit snapshot for next period");
        // Validate sum of rewards per network
        uint256 sum = 0;
        for (uint256 i = 0; i < _rewardsPerNetwork.length; i++){
            sum = sum.add(_rewardsPerNetwork[i]);
        }
        require(sum == _totalRewards, "Invalid rewards per network value");
        // Ensure total rewards does not exceed current balance
        require(_totalRewards <= getPendingRewards(), "Invalid total rewards");
//        // Check settings
//        RocketDAOProtocolSettingsNetworkInterface rocketDAOProtocolSettingsNetwork = RocketDAOProtocolSettingsNetworkInterface(getContractAddress("rocketDAOProtocolSettingsNetwork"));
//        require(rocketDAOProtocolSettingsNetwork.getSubmitBalancesEnabled(), "Submitting balances is currently disabled");
//        // Check block
//        require(_block < block.number, "Balances can not be submitted for a future block");
//        require(_block > getBalancesBlock(), "Network balances for an equal or higher block are set");
//        // Check balances
//        require(_stakingEth <= _totalEth, "Invalid network balances");
        // Get submission keys
        bytes32 nodeSubmissionKey = keccak256(abi.encodePacked("rewards.snapshot.submitted.node", msg.sender, _index, _totalRewards, _rewardsPerNetwork, _merkleRoot, _merkleTreeCID));
        bytes32 submissionCountKey = keccak256(abi.encodePacked("rewards.snapshot.submitted.count", msg.sender, _index, _totalRewards, _rewardsPerNetwork, _merkleRoot, _merkleTreeCID));
        // Check & update node submission status
        require(!getBool(nodeSubmissionKey), "Duplicate submission from node");
        setBool(nodeSubmissionKey, true);
        setBool(keccak256(abi.encodePacked("rewards.snapshot.submitted.node", msg.sender, _index)), true);
        // Increment submission count
        uint256 submissionCount = getUint(submissionCountKey).add(1);
        setUint(submissionCountKey, submissionCount);
        // Emit balances submitted event
        emit RewardSnapshotSubmitted(msg.sender, _index, _totalRewards, _rewardsPerNetwork, _merkleRoot, _merkleTreeCID, block.timestamp);
        // Check submission count & update network balances
        RocketDAONodeTrustedInterface rocketDAONodeTrusted = RocketDAONodeTrustedInterface(getContractAddress("rocketDAONodeTrusted"));
        if (calcBase.mul(submissionCount).div(rocketDAONodeTrusted.getMemberCount()) >= rocketDAOProtocolSettingsNetwork.getNodeConsensusThreshold()) {
            _insertSnapshot(_index, _totalRewards, _rewardsPerNetwork, _merkleRoot, _merkleTreeCID);
        }
    }

    // Executes updateBalances if consensus threshold is reached
    function executeUpdateBalances(uint256 _index, uint256 _totalRewards, uint256[] _rewardsPerNetwork, bytes32 _merkleRoot, Multihash calldata _merkleTreeCID) override external onlyLatestContract("rocketNetworkBalances", address(this)) {
//        // Check settings
//        RocketDAOProtocolSettingsNetworkInterface rocketDAOProtocolSettingsNetwork = RocketDAOProtocolSettingsNetworkInterface(getContractAddress("rocketDAOProtocolSettingsNetwork"));
//        require(rocketDAOProtocolSettingsNetwork.getSubmitBalancesEnabled(), "Submitting balances is currently disabled");
//        // Check block
//        require(_block < block.number, "Balances can not be submitted for a future block");
//        require(_block > getBalancesBlock(), "Network balances for an equal or higher block are set");
        // Get submission keys
        bytes32 submissionCountKey = keccak256(abi.encodePacked("rewards.snapshot.submitted.count", msg.sender, _index, _totalRewards, _rewardsPerNetwork, _merkleRoot, _merkleTreeCID));
        // Get submission count
        uint256 submissionCount = getUint(submissionCountKey);
        // Check submission count & update network balances
        RocketDAONodeTrustedInterface rocketDAONodeTrusted = RocketDAONodeTrustedInterface(getContractAddress("rocketDAONodeTrusted"));
        require(calcBase.mul(submissionCount).div(rocketDAONodeTrusted.getMemberCount()) >= rocketDAOProtocolSettingsNetwork.getNodeConsensusThreshold(), "Consensus has not been reached");
        _insertSnapshot(_index, _totalRewards, _rewardsPerNetwork, _merkleRoot, _merkleTreeCID);
    }

    // Update network balances
    function _insertSnapshot(uint256 _index, uint256 _totalRewards, uint256[] _rewardsPerNetwork, bytes32 _merkleRoot, Multihash calldata _merkleTreeCID) private {
        // Increment the reward index
        incrementRewardIndex();
        // Send out the rewards and merkle roots

        // Emit balances updated event
        emit RewardSnapshotInserted(_index, _totalRewards, _rewardsPerNetwork, _merkleRoot, _merkleTreeCID, block.timestamp);
    }

    // Returns the latest block number that oracles should be reporting balances for
    function getLatestReportableBlock() override external view returns (uint256) {
        // Load contracts
        RocketDAOProtocolSettingsNetworkInterface rocketDAOProtocolSettingsNetwork = RocketDAOProtocolSettingsNetworkInterface(getContractAddress("rocketDAOProtocolSettingsNetwork"));
        // Get the block balances were lasted updated and the update frequency
        uint256 updateFrequency = rocketDAOProtocolSettingsNetwork.getSubmitBalancesFrequency();
        // Calculate the last reportable block based on update frequency
        return block.number.div(updateFrequency).mul(updateFrequency);
    }
}
