pragma solidity 0.6.12;

// SPDX-License-Identifier: GPL-3.0-only

import "../RocketBase.sol";
import "../../interface/token/RocketTokenRPLInterface.sol";
import "../../interface/rewards/RocketRewardsPoolInterface.sol";
import "../../interface/settings/RocketDAOSettingsInterface.sol";
import "../../interface/RocketVaultInterface.sol";
import "../../interface/RocketVaultWithdrawerInterface.sol";

import "@openzeppelin/contracts/math/SafeMath.sol";


// Holds RPL generated by the network for claiming from stakers (node operators etc)

contract RocketRewardsPool is RocketBase, RocketRewardsPoolInterface {

    // Our base calc
    uint256 calcBase = 1 ether; 

    // Libs
    using SafeMath for uint;


    // Events
    event RPLTokensClaimed(address indexed claimingContract, address indexed claimingAddress, uint256 amount, uint256 time);  
    
    // Modifiers

    /**
    * @dev Throws if called by any sender that doesn't match a Rocket Pool claim contract
    */
    modifier onlyClaimContract() {
        // Will also throw if not a registered network contract or an old upgraded one
        RocketDAOSettingsInterface daoSettings = RocketDAOSettingsInterface(getContractAddress('rocketDAOSettings'));
        // They need a set claim amount > 0 to make a claim
        require(daoSettings.getRewardsClaimerPerc(getContractName(msg.sender)) > 0, "Not a valid rewards claiming contact");
        _;
    }


    // Construct
    constructor(address _rocketStorageAddress) RocketBase(_rocketStorageAddress) public {
        // Version
        version = 1;
        // Set the claim interval start block as the deployment block
        setUintS("rewards.pool.claim.interval.block.start", block.number);
    }

    /**
    * Get the last set interval start block
    * @return uint256 Last set start block for a claim interval
    */
    function getClaimIntervalBlockStart() override public view returns(uint256) {
        return getUintS("rewards.pool.claim.interval.block.start");
    }

    /**
    * Compute the current start block before a claim is made, takes into account intervals that may have passed
    * @return uint256 Computed starting block for next possible claim
    */
    function getClaimIntervalBlockStartComputed() override public view returns(uint256) {
        // If intervals have passed, a new start block will be used for the next claim, if it's the same interval then return that
        return getClaimIntervalsPassed() == 0 ? getClaimIntervalBlockStart() : getClaimIntervalBlockStart().add(getClaimIntervalBlocks().mul(getClaimIntervalsPassed()));
    }

    /**
    * Compute intervals since last claim period
    * @return uint256 Time intervals since last update
    */
    function getClaimIntervalsPassed() override public view returns(uint256) {
        // Calculate now if inflation has begun
        return block.number.sub(getClaimIntervalBlockStart()).div(getClaimIntervalBlocks());
    }

    /**
    * Get how many blocks in a claim interval
    * @return uint256 Number of blocks in a claim interval
    */
    function getClaimIntervalBlocks() override public view returns(uint256) {
        // Get from the DAO settings
        RocketDAOSettingsInterface daoSettings = RocketDAOSettingsInterface(getContractAddress('rocketDAOSettings'));
        return daoSettings.getRewardsClaimIntervalBlocks();
    }

    /**
    * Get the last block a claim was made
    * @return uint256 Last block a claim was made
    */
    function getClaimBlockLastMade() override public view returns(uint256) {
        return getUintS("rewards.pool.claim.interval.block.last");
    }

    /**
    * The current claim amount for this interval
    * @return uint256 The current claim amount for this interval for the claiming contract
    */
    function getClaimIntervalContractPerc(address _claimingContract) override public view returns(uint256) {
        // Get the dao settings contract instance
        RocketDAOSettingsInterface daoSettings = RocketDAOSettingsInterface(getContractAddress('rocketDAOSettings'));
        return getClaimIntervalsPassed() == 0 ? getUint(keccak256(abi.encodePacked("rewards.pool.claim.interval.contract.perc", _claimingContract))) : daoSettings.getRewardsClaimerPerc(getContractName(_claimingContract));
    }

    /**
    * The current claim amount total for this interval per claiming contract
    * @return uint256 The current claim amount for this interval for the claiming contract
    */
    function getClaimIntervalContractTotalClaimed(address _claimingContract) override public view returns(uint256) {
        return getUint(keccak256(abi.encodePacked("rewards.pool.claim.interval.contract.total", getClaimIntervalBlockStartComputed(), _claimingContract)));
    }


    /**
    * Have they claimed already during this interval? 
    * @return bool Returns true if they can claim during this interval
    */
    function getClaimIntervalHasClaimed(uint256 _claimIntervalStartBlock, address _claimingContract, address _claimerAddress) override public view returns(bool) {
        // Check per contract
        return getBool(keccak256(abi.encodePacked("rewards.pool.claim.interval.claimer.address", _claimIntervalStartBlock, _claimingContract, _claimerAddress)));
    }

    /**
    * Get the approx amount of rewards available for this claim interval
    * @return uint256 Rewards amount for current claim interval
    */
    function getClaimIntervalRewardsTotal() override public view returns(uint256) {
        // Get the RPL contract instance
        RocketTokenRPLInterface rplContract = RocketTokenRPLInterface(getContractAddress('rocketTokenRPL'));
        // Get the vault contract instance
        RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress('rocketVault'));
        // Rewards amount
        uint256 rewardsTotal = 0;
        // Is this the first claim of this interval? If so, calculate expected inflation RPL + any RPL already in the pool
        if(getClaimIntervalsPassed() > 0) {
            // Get the balance of tokens that will be transferred to the vault for this contract when the first claim is made
            // Also account for any RPL tokens already in the vault for the rewards pool
            rewardsTotal = rplContract.inflationCalculate().add(rocketVault.balanceOfToken('rocketRewardsPool', getContractAddress('rocketTokenRPL')));
        }else{
            // Claims have already been made, lets retrieve rewards total stored on first claim of this interval
            rewardsTotal = getUintS("rewards.pool.claim.interval.total");
        }
        // Done
        return rewardsTotal;
    }

    /**
    * Get the approx amount of rewards available for this claim interval per claiming contract
    * @return uint256 Rewards amount for current claim interval per claiming contract
    */
    function getClaimIntervalContractTotalRewards(address _claimContract) override public view returns(uint256) {
        // Get the amount allocated to this claim contract
        uint256 claimContractPerc = getClaimIntervalContractPerc(_claimContract);
        // How much rewards are available for this claim interval?
        uint256 claimIntervalRewardsTotal = getClaimIntervalRewardsTotal();
        // How much this claiming contract is entitled too in perc
        uint256 contractClaimTotal = 0;
        // Check now
        if(claimContractPerc > 0 && claimIntervalRewardsTotal > 0)  {
            // Calculate how much rewards this claimer will receive based on their claiming perc
            contractClaimTotal = claimContractPerc.mul(claimIntervalRewardsTotal).div(calcBase);
        }
        // Done
        return contractClaimTotal;
    }
    
    // How much this claimer is entitled to claim, checks parameters that claim() will check
    function getClaimAmount(address _claimContract, address _claimerAddress, uint256 _claimerAmountPerc) override public view returns (uint256) { 
        // Get the total rewards available for this claiming contract
        uint256 contractClaimTotal = getClaimIntervalContractTotalRewards(_claimContract);
        // How much of the above that this claimer will receive
        uint256 claimerTotal = 0;
        // Are we good to proceed?
        if(contractClaimTotal > 0 && 
               _claimerAmountPerc > 0 && 
               _claimerAmountPerc <= 1 ether &&
               _claimerAddress != address(0x0) && 
               !getClaimIntervalHasClaimed(getClaimIntervalBlockStartComputed(), _claimContract, _claimerAddress)) {

             // Now calculate how much this claimer would receive 
            claimerTotal = _claimerAmountPerc.mul(contractClaimTotal).div(calcBase);
            // Is it more than currently available + the amount claimed already for this claim interval?
            claimerTotal = claimerTotal.add(getClaimIntervalContractTotalClaimed(msg.sender)) <= getClaimIntervalContractTotalRewards(msg.sender) ? claimerTotal : 0;
            
        }
        // Done
        return claimerTotal;
    }

    // A claiming contract claiming for a user and the percentage of the rewards they are allowed to receive
    function claim(address _claimerAddress, uint256 _claimerAmountPerc) override external onlyClaimContract {
        // RPL contract address
        address rplContractAddress = getContractAddress('rocketTokenRPL');
        // Get the dao settings contract instance
        RocketDAOSettingsInterface daoSettings = RocketDAOSettingsInterface(getContractAddress('rocketDAOSettings'));
        // RPL contract instance
        RocketTokenRPLInterface rplContract = RocketTokenRPLInterface(rplContractAddress);
        // Get the vault contract instance
        RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress('rocketVault'));
        // Get the start of the last claim interval as this may have just changed for a new interval beginning
        uint256 claimIntervalBlockStart = getClaimIntervalBlockStartComputed();
        // Is this the first claim of this interval? If so, set the rewards total for this interval
        if(getClaimIntervalsPassed() > 0) {
            // Get the amount allocated to this claim contract
            uint256 claimContractPerc = daoSettings.getRewardsClaimerPerc(getContractName(msg.sender));
            // Make sure this is ok
            require(claimContractPerc > 0 && claimContractPerc <= 1 ether, "Claiming contract cannot claim more than 100%");
            // Before we mint new tokens, transfer whatever is left in there from the previous claiming interval to the DAO, it will build up until the DAO address is set
            address daoClaimAddress = daoSettings.getRewardsDAOAddress();
            // Only send when a valid address is set, until then the rewards for the DAO will build up here
            if(daoClaimAddress != address(0x0)) rocketVault.withdrawToken(daoClaimAddress, rplContractAddress, rocketVault.balanceOfToken('rocketRewardsPool', rplContractAddress));
            // Check if any inflation intervals have passed and only mint if needed to the vault before we record the total RPL available for this interval
            if(rplContract.getInlfationIntervalsPassed() > 0) rplContract.inflationMintTokens();
            // Get how many tokens are in the reward pool to be available for this claim period
            setUintS("rewards.pool.claim.interval.total", rocketVault.balanceOfToken('rocketRewardsPool', rplContractAddress));
            // Set this as the start of the new claim interval
            setUintS("rewards.pool.claim.interval.block.start", claimIntervalBlockStart);
            // Set the current claim amount perc for this contract for this claim interval (if the claim amount is changed, it will kick in on the next interval)
            setUint(keccak256(abi.encodePacked("rewards.pool.claim.interval.contract.perc", msg.sender)), claimContractPerc);
        }
        // Check if they have a valid claim amount
        uint256 claimAmount = getClaimAmount(msg.sender, _claimerAddress, _claimerAmountPerc);
        // First initial checks
        require(claimAmount > 0, "Claimer is not entitled to tokens, they have already claimed in this interval or they are claiming more rewards than available to this claiming contract.");
        // Send tokens now
        rocketVault.withdrawToken(_claimerAddress, rplContractAddress, claimAmount);
        // Store the claiming record for this interval and claiming contract
        setBool(keccak256(abi.encodePacked("rewards.pool.claim.interval.claimer.address", claimIntervalBlockStart, msg.sender, _claimerAddress)), true);
        // Store the last block a claim was made
        setUintS("rewards.pool.claim.interval.block.last", block.number);
        // Store the total RPL rewards claim for this claiming contract in this interval
        setUint(keccak256(abi.encodePacked("rewards.pool.claim.interval.contract.total", claimIntervalBlockStart, msg.sender)), getClaimIntervalContractTotalClaimed(msg.sender).add(claimAmount));
        // Log it
        emit RPLTokensClaimed(msg.sender, _claimerAddress, claimAmount, now);
    }

}
