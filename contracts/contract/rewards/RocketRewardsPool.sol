pragma solidity 0.7.6;
pragma abicoder v2;

// SPDX-License-Identifier: GPL-3.0-only

import "../RocketBase.sol";
import "../../interface/token/RocketTokenRPLInterface.sol";
import "../../interface/rewards/RocketRewardsPoolInterface.sol";
import "../../interface/dao/protocol/settings/RocketDAOProtocolSettingsNetworkInterface.sol";
import "../../interface/dao/node/RocketDAONodeTrustedInterface.sol";
import "../../interface/network/RocketNetworkBalancesInterface.sol";
import "../../interface/RocketVaultInterface.sol";
import "../../interface/dao/protocol/settings/RocketDAOProtocolSettingsRewardsInterface.sol";
import "../../interface/rewards/RocketRewardsRelayInterface.sol";
import "../../interface/rewards/RocketSmoothingPoolInterface.sol";
import "@openzeppelin/contracts/math/SafeMath.sol";


// Holds RPL generated by the network for claiming from stakers (node operators etc)

contract RocketRewardsPool is RocketBase, RocketRewardsPoolInterface {

    // Libs
    using SafeMath for uint256;

    // Events
    event RewardSnapshotSubmitted(address indexed from, uint256 indexed index, uint256 block, uint256[] rewardsPerNetworkRPL, uint256[] rewardsPerNetworkETH, bytes32 merkleRoot, string merkleTreeCID, uint256 time);
    event RewardSnapshot(uint256 indexed index, uint256 block, uint256[] rewardsPerNetworkRPL, uint256[] rewardsPerNetworkETH, bytes32 merkleRoot, string merkleTreeCID, uint256 time);

    // Construct
    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {
        // Version
        version = 2;
    }

    function getRewardIndex() override public view returns(uint256) {
        return getUint(keccak256("rewards.snapshot.index"));
    }
    function incrementRewardIndex() private {
        addUint(keccak256("rewards.snapshot.index"), 1);
    }

    /**
    * Get how much RPL the Rewards Pool contract currently has assigned to it as a whole
    * @return uint256 Returns rpl balance of rocket rewards contract
    */
    function getRPLBalance() override public view returns(uint256) {
        // Get the vault contract instance
        RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress("rocketVault"));
        // Check contract RPL balance
        return rocketVault.balanceOfToken("rocketRewardsPool", IERC20(getContractAddress("rocketTokenRPL")));
    }

    // Returns the total amount of RPL that needs to be distributed to claimers at the current block
    function getPendingRPLRewards() override public view returns (uint256) {
        RocketTokenRPLInterface rplContract = RocketTokenRPLInterface(getContractAddress("rocketTokenRPL"));
        uint256 pendingInflation = rplContract.inflationCalculate();
        // Any inflation that has accrued so far plus any amount that would be minted if we called it now
        return getRPLBalance().add(pendingInflation);
    }

    // Returns the total amount of ETH in the smoothing pool ready to be distributed
    function getPendingETHRewards() override public view returns (uint256) {
        address rocketSmoothingPoolAddress = getContractAddress("rocketSmoothingPool");
        return rocketSmoothingPoolAddress.balance;
    }

    /**
    * Get the last set interval start time
    * @return uint256 Last set start timestamp for a claim interval
    */
    function getClaimIntervalTimeStart() override public view returns(uint256) {
        return getUint(keccak256("rewards.pool.claim.interval.time.start"));
    }

    /**
    * Get how many seconds in a claim interval
    * @return uint256 Number of seconds in a claim interval
    */
    function getClaimIntervalTime() override public view returns(uint256) {
        // Get from the DAO settings
        RocketDAOProtocolSettingsRewardsInterface daoSettingsRewards = RocketDAOProtocolSettingsRewardsInterface(getContractAddress("rocketDAOProtocolSettingsRewards"));
        return daoSettingsRewards.getRewardsClaimIntervalTime();
    }

    /**
    * Compute intervals since last claim period
    * @return uint256 Time intervals since last update
    */
    function getClaimIntervalsPassed() override public view returns(uint256) {
        return block.timestamp.sub(getClaimIntervalTimeStart()).div(getClaimIntervalTime());
    }

    /**
    * Get the percentage this contract can claim in this interval
    * @return uint256 Rewards percentage this contract can claim in this interval
    */
    function getClaimingContractPerc(string memory _claimingContract) override public view returns(uint256) {
        // Load contract
        RocketDAOProtocolSettingsRewardsInterface daoSettingsRewards = RocketDAOProtocolSettingsRewardsInterface(getContractAddress("rocketDAOProtocolSettingsRewards"));
        // Get the % amount allocated to this claim contract
        return daoSettingsRewards.getRewardsClaimerPerc(_claimingContract);
    }

    // Submit a reward snapshot
    // Only accepts calls from trusted (oracle) nodes
    function submitRewardSnapshot(uint256 _index, uint256 _block, uint256[] memory _rewardsPerNetworkRPL, uint256[] memory _rewardsPerNetworkETH, bytes32 _merkleRoot, string calldata _merkleTreeCID) override external onlyLatestContract("rocketRewardsPool", address(this)) onlyTrustedNode(msg.sender) {
        // Validate inputs
        require(_index == getRewardIndex(), "Can only submit snapshot for next period");
        require(_rewardsPerNetworkRPL.length == _rewardsPerNetworkETH.length, "Invalid size rewards array");
        // Calculate RPL reward total and validate
        uint256 totalRewardsRPL = 0;
        for (uint256 i = 0; i < _rewardsPerNetworkRPL.length; i++){
            totalRewardsRPL = totalRewardsRPL.add(_rewardsPerNetworkRPL[i]);
        }
        require(totalRewardsRPL <= getPendingRPLRewards(), "Invalid RPL rewards");
        // Calculate ETH reward total and validate
        { // Scope to prevent stake too deep
            uint256 totalRewardsETH = 0;
            for (uint256 i = 0; i < _rewardsPerNetworkETH.length; i++){
                totalRewardsETH = totalRewardsETH.add(_rewardsPerNetworkETH[i]);
            }
            require(totalRewardsETH <= getPendingETHRewards(), "Invalid ETH rewards");
        }
        // Store and increment vote
        uint256 submissionCount;
        { // Scope to prevent stake too deep
            bytes32 nodeSubmissionKey = keccak256(abi.encodePacked("rewards.snapshot.submitted.node", msg.sender, _index, _block, _rewardsPerNetworkRPL, _rewardsPerNetworkETH, _merkleRoot, _merkleTreeCID));
            bytes32 submissionCountKey = keccak256(abi.encodePacked("rewards.snapshot.submitted.count", _index, _block, _rewardsPerNetworkRPL, _rewardsPerNetworkETH, _merkleRoot, _merkleTreeCID));
            // Check & update node submission status
            require(!getBool(nodeSubmissionKey), "Duplicate submission from node");
            setBool(nodeSubmissionKey, true);
            setBool(keccak256(abi.encodePacked("rewards.snapshot.submitted.node", msg.sender, _index)), true);
            // Increment submission count
            submissionCount = getUint(submissionCountKey).add(1);
            setUint(submissionCountKey, submissionCount);
        }
        // Emit snapshot submitted event
        emit RewardSnapshotSubmitted(msg.sender, _index, _block, _rewardsPerNetworkRPL, _rewardsPerNetworkETH, _merkleRoot, _merkleTreeCID, block.timestamp);
        // If consensus is reached, execute the snapshot
        RocketDAOProtocolSettingsNetworkInterface rocketDAOProtocolSettingsNetwork = RocketDAOProtocolSettingsNetworkInterface(getContractAddress("rocketDAOProtocolSettingsNetwork"));
        RocketDAONodeTrustedInterface rocketDAONodeTrusted = RocketDAONodeTrustedInterface(getContractAddress("rocketDAONodeTrusted"));
        if (calcBase.mul(submissionCount).div(rocketDAONodeTrusted.getMemberCount()) >= rocketDAOProtocolSettingsNetwork.getNodeConsensusThreshold()) {
            _executeRewardSnapshot(_index, _block, totalRewardsRPL, _rewardsPerNetworkRPL, _rewardsPerNetworkETH, _merkleRoot, _merkleTreeCID);
        }
    }

    // Executes updateBalances if consensus threshold is reached
    function executeRewardSnapshot(uint256 _index, uint256 _block, uint256[] memory _rewardsPerNetworkRPL, uint256[] memory _rewardsPerNetworkETH, bytes32 _merkleRoot, string calldata _merkleTreeCID) override external onlyLatestContract("rocketNetworkBalances", address(this)) {
        // Calculate total
        uint256 totalRewardsRPL = 0;
        for (uint256 i = 0; i < _rewardsPerNetworkRPL.length; i++){
            totalRewardsRPL = totalRewardsRPL.add(_rewardsPerNetworkRPL[i]);
        }
        // Get submission count
        bytes32 submissionCountKey = keccak256(abi.encodePacked("rewards.snapshot.submitted.count", msg.sender, _index, _block, _rewardsPerNetworkRPL, _rewardsPerNetworkETH, _merkleRoot, _merkleTreeCID));
        uint256 submissionCount = getUint(submissionCountKey);
        // Confirm consensus and execute
        RocketDAONodeTrustedInterface rocketDAONodeTrusted = RocketDAONodeTrustedInterface(getContractAddress("rocketDAONodeTrusted"));
        RocketDAOProtocolSettingsNetworkInterface rocketDAOProtocolSettingsNetwork = RocketDAOProtocolSettingsNetworkInterface(getContractAddress("rocketDAOProtocolSettingsNetwork"));
        require(calcBase.mul(submissionCount).div(rocketDAONodeTrusted.getMemberCount()) >= rocketDAOProtocolSettingsNetwork.getNodeConsensusThreshold(), "Consensus has not been reached");
        _executeRewardSnapshot(_index, _block, totalRewardsRPL, _rewardsPerNetworkRPL, _rewardsPerNetworkETH, _merkleRoot, _merkleTreeCID);
    }

    // Update network balances
    function _executeRewardSnapshot(uint256 _index, uint256 _block, uint256 _totalRewardsRPL, uint256[] memory _rewardsPerNetworkRPL, uint256[] memory _rewardsPerNetworkETH, bytes32 _merkleRoot, string calldata _merkleTreeCID) private {
        // Get contract
        RocketTokenRPLInterface rplContract = RocketTokenRPLInterface(getContractAddress("rocketTokenRPL"));
        RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress("rocketVault"));
        // Execute inflation if required
        rplContract.inflationMintTokens();
        // Increment the reward index and update the claim interval timestamp
        incrementRewardIndex();
        setUint(keccak256("rewards.pool.claim.interval.time.start"), getClaimIntervalTimeStart().add(getClaimIntervalTime()));
        // Send out the treasury rewards
        { // Scope to prevent stack too deep
            uint256 daoClaimContractPerc = getClaimingContractPerc("rocketClaimDAO");
            if (daoClaimContractPerc > 0) {
                // Get the DAO claim contract address
                address daoClaimContractAddress = getContractAddress("rocketClaimDAO");
                // Transfers the DAO's tokens to it's claiming contract from the rewards pool
                rocketVault.transferToken("rocketClaimDAO", rplContract, daoClaimContractPerc.mul(_totalRewardsRPL).div(calcBase));
            }
        }
        // Send out the node and trusted node rewards and merkle roots
        for (uint i = 0; i < _rewardsPerNetworkRPL.length; i++) {
            // Quick out if no rewards for this network
            uint256 rewardsRPL = _rewardsPerNetworkRPL[i];
            uint256 rewardsETH = _rewardsPerNetworkETH[i];
            if (rewardsRPL == 0 && rewardsETH == 0) {
                continue;
            }
            // Grab the relay address
            RocketRewardsRelayInterface relay;
            { // Scope to prevent stack too deep
                address networkRelayAddress;
                bytes32 networkRelayKey = keccak256(abi.encodePacked("rewards.relay.address", i));
                networkRelayAddress = getAddress(networkRelayKey);
                // Validate network is valid
                require (networkRelayAddress != address(0), "Snapshot contains rewards for invalid network");
                relay = RocketRewardsRelayInterface(networkRelayAddress);
            }
            // Transfer rewards and call relay
            if (rewardsRPL > 0) {
                rocketVault.withdrawToken(address(relay), rplContract, rewardsRPL);
            }
            if (rewardsETH > 0) {
                RocketSmoothingPoolInterface rocketSmoothingPool = RocketSmoothingPoolInterface(getContractAddress("rocketSmoothingPool"));
                rocketSmoothingPool.withdrawEther(address(relay), rewardsETH);
            }
            relay.relayRewards(_index, _merkleRoot, rewardsRPL, rewardsETH);
        }
        // Emit balances updated event
        emit RewardSnapshot(_index, _block, _rewardsPerNetworkRPL, _rewardsPerNetworkETH, _merkleRoot, _merkleTreeCID, block.timestamp);
    }
}
