pragma solidity 0.6.12;

// SPDX-License-Identifier: GPL-3.0-only

import "../RocketBase.sol";
import "../../interface/token/RocketTokenRPLInterface.sol";
import "../../interface/rewards/RocketRewardsPoolInterface.sol";
import "../../interface/settings/RocketDAOSettingsInterface.sol";
import "../../interface/RocketVaultInterface.sol";
import "../../interface/RocketVaultWithdrawerInterface.sol";

import "@openzeppelin/contracts/math/SafeMath.sol";


// Holds RPL generated by the network for claiming from stakers (node operators etc)

contract RocketRewardsPool is RocketBase, RocketRewardsPoolInterface {

    // Libs
    using SafeMath for uint;

    // The names of contracts that can claim
    mapping(string => bool) claimingContracts;

    // Events
    event RPLTokensDeposited(uint256 amount, uint256 time);

    // Contracts
    // RocketVaultInterface rocketVault = RocketVaultInterface(0);
    // RocketDAOSettingsInterface daoSettings = RocketDAOSettingsInterface(0);
    
    
    // Modifiers

    /**
    * @dev Throws if called by any sender that doesn't match a Rocket Pool claim contract
    */
    modifier onlyClaimContract() {
        // Will also throw if not a registered network contract or an old upgraded one
        RocketDAOSettingsInterface daoSettings = RocketDAOSettingsInterface(getContractAddress('rocketDAOSettings'));
        // They need a set claim amount > 0 to make a claim
        require(daoSettings.getRewardsClaimerPerc(getContractName(msg.sender)) > 0, "Not a valid rewards claiming contact");
        _;
    }


    // Construct
    constructor(address _rocketStorageAddress) RocketBase(_rocketStorageAddress) public {
        // Version
        version = 1;
        // Set the claim interval start block as the deployment block
        setUintS("rewards.pool.claim.interval.block.start", block.number);
    }

    /**
    * Get the starting block for this claim interval
    * @return uint256 Starting block for this claim interval
    */
    function getClaimIntervalBlockStart() override public view returns(uint256) {
        return getUintS("rewards.pool.claim.interval.block.start");
    }


    /**
    * Get the ending block for this claim interval
    * @return uint256 Ending block for this claim interval
    
    function getClaimIntervalBlockEnd() override public view returns(uint256) {
        // Get the start block
        uint256 startBlock = getUintS("rewards.pool.claim.interval.block.start");
        // If no intervals have passed, end block is start + interval amount, otherwise it's intervals missed * interval amount
        return getClaimIntervalBlocks() > 0 ? 
        return getUintS("rewards.pool.claim.interval.block.start").add(getClaimIntervalBlocks());
    }*/

    /**
    * Get how many blocks in a claim interval
    * @return uint256 Number of blocks in a claim interval
    */
    function getClaimIntervalBlocks() override public view returns(uint256) {
        // Get from the DAO settings
        RocketDAOSettingsInterface daoSettings = RocketDAOSettingsInterface(getContractAddress('rocketDAOSettings'));
        return daoSettings.getRewardsClaimIntervalBlocks();
    }

    /**
    * Get the last block a claim was made
    * @return uint256 Last block a claim was made
    */
    function getClaimBlockLastMade() override public view returns(uint256) {
        return getUintS("rewards.pool.claim.interval.block.last");
    }


    /**
    * Compute intervals since last claim period
    * @return uint256 Time intervals since last update
    */
    function getClaimIntervalsPassed() override public view returns(uint256) {
        // Calculate now if inflation has begun
        return block.number.sub(getClaimIntervalBlockStart()).div(getClaimIntervalBlocks());
    }

    /**
    * Get the approx amount of rewards available for this claim interval
    * @return uint256 Rewards amount for current claim interval
    */
    function getClaimIntervalRewardsTotal() override public view returns(uint256) {
        // Get the RPL contract instance
        RocketTokenRPLInterface rplContract = RocketTokenRPLInterface(getContractAddress('rocketTokenRPL'));
        // Get the vault contract instance
        RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress('rocketVault'));
        // Rewards amount
        uint256 rewardsTotal = 0;
        // Is this the first claim of this interval? If so, calculate expected inflation RPL + any RPL already in the pool
        if(getClaimIntervalsPassed() > 0) {
            // Get the balance of tokens that will be transferred to the vault for this contract when the first claim is made
            // Also account for any RPL tokens already in the vault for the rewards pool
            rewardsTotal = rplContract.inflationCalculate().add(rocketVault.balanceOfToken('rocketRewardsPool', getContractAddress('rocketTokenRPL')));
        }else{
            // Claims have already been made, lets retrieve rewards total stored on first claim of this interval
            rewardsTotal = getUintS("rewards.pool.claim.interval.total");
        }
        // Done
        return rewardsTotal;
    }
    
    // How much this claimer is entitled to claim, returns 0 if they have already claimed or the claimer contract perc is 0
    function claimAmount(address _claimerAddress, uint256 _claimerAmountPerc) override public onlyClaimContract returns (uint256) { 
        // Get the dao settings contract instance
        RocketDAOSettingsInterface daoSettings = RocketDAOSettingsInterface(getContractAddress('rocketDAOSettings'));
        // Our base calc
        uint256 calcBase = 1 ether;
        // Get the amount allocated to this claim contract
        uint256 claimContractPerc = daoSettings.getRewardsClaimerPerc(getContractName(msg.sender));
        // How much rewards are available for this claim interval?
        uint256 claimIntervalRewardsTotal = getClaimIntervalRewardsTotal();
        // How much this claiming contract is entitled too in perc
        uint256 contractClaimTotal = 0;
        // Are we good to proceed?
        if(claimContractPerc > 0 && claimIntervalRewardsTotal > 0) {
            // Calculate this contracts max claim amount
            contractClaimTotal = calcBase.mul(_claimerAmountPerc).div(claimIntervalRewardsTotal);
        }

        return contractClaimTotal;

        /*
        // Get the last time a claim was made
        uint256 claimLastMadeBlock = getUintS("rewards.pool.claim.period.claim.block.last");
        // Get the interval start block
        uint256 claimIntervalStartBlock = getUintS("rewards.pool.claim.period.interval.block.start");
        // Is this the first claim of this interval?
        if(claimLastMadeBlock < claimIntervalStartBlock) {

        }
        // Get the amount of rewards in the pool available

        // Get the last claim period start block
        uint256 lastClaimIntervalStartBlock = getUintS("rewards.pool.claim.period.interval.block.start");
        // How much has this claimer claimed in this interval?
        uint256 claimAmountAllowed = getUint(keccak256(abi.encodePacked("rewards.pool.claim.period.interval.claimed", lastClaimIntervalStartBlock, _claimer)));
        uint256 claimAmountWithdrawn = getUint(keccak256(abi.encodePacked("rewards.pool.claim.period.interval.claimed", lastClaimIntervalStartBlock, _claimer)));
        // Claimer can only claim once per claim interval, check if they have already claimed any amount
 
        /*

        // Our claim period in blocks
        uint256 claimIntervalBlocks = daoSettings.getRewardsClaimIntervalBlocks();
        // Get the last claim period block
        uint256 lastClaimIntervalBlock = getUintS("rewards.pool.claim.period.interval.block.start");
        // Has the last claim period past yet?
        if(lastClaimIntervalBlock.add(claimIntervalBlocks) < block.number) {
            return true;
        }
        // Not yet
        return false;
        */

    }

    // A claiming contract claiming for a user and the amount of rewards they need
    function claim(address _claimerAddress, uint256 _claimerAmount) override external onlyClaimContract {
        // First initial checks
        require(_claimerAmount > 0, "Claimer must claim more than zero");
        require(_claimerAddress != address(0x0), "Claimer address is not valid");
        // RPL contract instance
        RocketTokenRPLInterface rplContract = RocketTokenRPLInterface(getContractAddress('rocketTokenRPL'));
        // Get the vault contract instance
        RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress('rocketVault'));
        // Get the start of the last claim interval
        uint256 claimIntervalBlockStart = getClaimIntervalBlockStart();
        // Is this the first claim of this interval? If so, set the rewards total for this interval
        if(getClaimIntervalsPassed() > 0) {
            // Check if any inflation intervals have passed and only mint if needed to the vault before we record the total RPL available for this interval
            if(rplContract.getInlfationIntervalsPassed() > 0) rplContract.inflationMintTokens();
            // Get how many tokens are in the reward pool to be available for this claim period
            setUintS("rewards.pool.claim.interval.total", rocketVault.balanceOfToken('rocketRewardsPool', getContractAddress('rocketTokenRPL')));
            // Set this as the start of the next claim interval
            setUintS("rewards.pool.claim.interval.block.start", claimIntervalBlockStart.add(getClaimIntervalBlocks().mul(getClaimIntervalsPassed())));
        }
        // Now calculate the %
        // Store the last block a claim was made
        setUintS("rewards.pool.claim.interval.block.last", block.number);
        /*
        // Get the dao settings contract instance
        //daoSettings = RocketDAOSettingsInterface(getContractAddress('rocketDAOSettings'));
        // Get the vault contract instance
        //rocketVault = RocketVaultInterface(getContractAddress('rocketVault'));
        // Only claim after inflation has started
        // require(daoSettings.getInflationIntervalStartBlock() < block.number, "Claiming cannot start until rewards are being generated");
        // Make sure they can claim now
        //require(canClaim(_claimer), "Claim period has not passed for claiming rewards yet");

        // Call the RPL inflation function to mint any tokens that are due before processing claim


        // If this was the first claim of the period, save the total amount in the rewards pool for this claims interval
        if(getUintS("rewards.pool.claim.period.claimLastBlock") < getUintS("rewards.pool.claim.period.interval.block.start")) {
            // Get how many tokens are in the reward pool to be available for this claim period
            setUintS("rewards.pool.claim.period.rewards.total", rocketVault.balanceOfToken('rocketRewardsPool', getContractAddress('rocketTokenRPL')));
            // If there's any rewards left for this claim period, send to the DAO
            
            //setUintS("rewards.pool.claim.period.rewards.total", lastClaimIntervalBlock.add(claimIntervalBlocks));
        } 
        // Get the last claim period block
        uint256 lastClaimIntervalBlock = getUintS("rewards.pool.claim.period.interval.block.start");
        // Our claim period in blocks
        uint256 claimIntervalBlocks = daoSettings.getRewardsClaimIntervalBlocks();
        // Update the latest claim interval period block now
        setUintS("rewards.pool.claim.period.claimLastBlock", lastClaimIntervalBlock.add(claimIntervalBlocks));
        // Update the last block a successful claim was made at
        setUintS("rewards.pool.claim.period.lastClaim", block.number);
        */
    }

}
